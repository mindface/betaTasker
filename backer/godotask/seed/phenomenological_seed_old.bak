package seed

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"path/filepath"
	"time"

	"github.com/godotask/model"
	"gorm.io/gorm"
)

// SeedPhenomenologicalData - 現象学的フレームワークのシードデータ
func SeedPhenomenologicalData(db *gorm.DB) error {
	log.Println("Seeding phenomenological framework data...")

	// JSONファイルからのデータ読み込み（存在する場合）
	if err := loadPhenomenologicalFromJSON(db); err != nil {
		log.Printf("Warning: Failed to load JSON seed data: %v", err)
	}

	// プログラマティックなシードデータ
	if err := seedPhenomenologicalFrameworks(db); err != nil {
		return fmt.Errorf("failed to seed frameworks: %v", err)
	}

	if err := seedKnowledgePatterns(db); err != nil {
		return fmt.Errorf("failed to seed knowledge patterns: %v", err)
	}

	if err := seedOptimizationModels(db); err != nil {
		return fmt.Errorf("failed to seed optimization models: %v", err)
	}

	if err := seedRobotSpecifications(db); err != nil {
		return fmt.Errorf("failed to seed robot specifications: %v", err)
	}

	log.Println("✓ Phenomenological framework data seeded successfully")
	return nil
}

// loadPhenomenologicalFromJSON - JSONファイルからデータを読み込み
func loadPhenomenologicalFromJSON(db *gorm.DB) error {
	seedDir := "seed/data"
	
	// 現象学的フレームワーク
	frameworksFile := filepath.Join(seedDir, "phenomenological_frameworks.json")
	if data, err := ioutil.ReadFile(frameworksFile); err == nil {
		var frameworks []model.PhenomenologicalFramework
		if err := json.Unmarshal(data, &frameworks); err == nil {
			for _, framework := range frameworks {
				var existing model.PhenomenologicalFramework
				if err := db.Where("id = ?", framework.ID).First(&existing).Error; err == gorm.ErrRecordNotFound {
					if err := db.Create(&framework).Error; err != nil {
						log.Printf("Failed to create framework %s: %v", framework.ID, err)
					}
				}
			}
		}
	}

	// 知識パターン
	patternsFile := filepath.Join(seedDir, "knowledge_patterns.json")
	if data, err := ioutil.ReadFile(patternsFile); err == nil {
		var patterns []model.KnowledgePattern
		if err := json.Unmarshal(data, &patterns); err == nil {
			for _, pattern := range patterns {
				var existing model.KnowledgePattern
				if err := db.Where("id = ?", pattern.ID).First(&existing).Error; err == gorm.ErrRecordNotFound {
					if err := db.Create(&pattern).Error; err != nil {
						log.Printf("Failed to create pattern %s: %v", pattern.ID, err)
					}
				}
			}
		}
	}

	return nil
}

// seedPhenomenologicalFrameworks - 現象学的フレームワークのシード
func seedPhenomenologicalFrameworks(db *gorm.DB) error {
	frameworks := []model.PhenomenologicalFramework{
		{
			ID:          "robot_precision_framework",
			Name:        "ロボット精度最適化フレームワーク",
			Description: "位置決め精度を目的とした現象学的アプローチ",
			Goal:        "G: 位置決め精度±0.01mm達成",
			Scope:       "A: 6軸ロボットアームの動作範囲全体",
			Process: model.JSON(map[string]interface{}{
				"Pa": "キャリブレーション→測定→補正→検証の反復プロセス",
				"steps": []string{"初期測定", "誤差解析", "補正値計算", "適用", "再測定"},
				"feedback_loop": "continuous",
			}),
			Result: model.JSON(map[string]interface{}{
				"achieved_accuracy": 0.012,
				"iterations": 5,
				"convergence_rate": 0.95,
			}),
			Feedback: model.JSON(map[string]interface{}{
				"type": "continuous",
				"method": "レーザートラッカーによる実時間測定",
				"interval": "100ms",
			}),
			LimitMin:      0.005,
			LimitMax:      0.02,
			GoalFunction:  "minimize(abs(measured_position - target_position))",
			AbstractLevel: "L1",
			Domain:        "robot_calibration",
			CreatedAt:     time.Now(),
			UpdatedAt:     time.Now(),
		},
		{
			ID:          "adaptive_learning_framework",
			Name:        "適応学習フレームワーク",
			Description: "作業環境変化への自律適応",
			Goal:        "G: 未知物体への適応時間<10秒",
			Scope:       "A: 製造ライン上の多様な部品",
			Process: model.JSON(map[string]interface{}{
				"Pa": "観察→特徴抽出→戦略選択→実行→評価",
				"learning_method": "reinforcement_learning",
				"update_frequency": "real_time",
			}),
			LimitMin:      1.0,
			LimitMax:      10.0,
			GoalFunction:  "minimize(adaptation_time) + maximize(success_rate)",
			AbstractLevel: "L2",
			Domain:        "robot_learning",
			CreatedAt:     time.Now(),
			UpdatedAt:     time.Now(),
		},
	}

	for _, framework := range frameworks {
		var existing model.PhenomenologicalFramework
		if err := db.Where("id = ?", framework.ID).First(&existing).Error; err == gorm.ErrRecordNotFound {
			if err := db.Create(&framework).Error; err != nil {
				return err
			}
		} else {
			// 既存データの更新オプション
			if shouldUpdateExisting() {
				if err := db.Model(&existing).Updates(&framework).Error; err != nil {
					return err
				}
			}
		}
	}

	return nil
}

// seedKnowledgePatterns - 知識パターンのシード
func seedKnowledgePatterns(db *gorm.DB) error {
	patterns := []model.KnowledgePattern{
		{
			ID:             "assembly_skill_pattern",
			Type:           "tacit",
			Domain:         "robot_assembly",
			TacitKnowledge: "熟練工の『しっくりくる』感覚",
			ExplicitForm:   "力覚センサ値: Fx<0.5N, Fy<0.5N, Tz<0.1Nm",
			ConversionPath: model.JSON(map[string]interface{}{
				"SECI": []string{"共同化", "表出化", "連結化", "内面化"},
				"method": "力覚データ記録→パターン分析→閾値設定",
				"validation": "熟練工による検証",
			}),
			Accuracy:      0.85,
			Coverage:      0.75,
			Consistency:   0.90,
			AbstractLevel: "L1",
			CreatedAt:     time.Now(),
			UpdatedAt:     time.Now(),
		},
		{
			ID:             "quality_inspection_pattern",
			Type:           "hybrid",
			Domain:         "robot_inspection",
			TacitKnowledge: "検査員の違和感察知",
			ExplicitForm:   "異常検知アルゴリズム: Isolation Forest, threshold=0.05",
			ConversionPath: model.JSON(map[string]interface{}{
				"process": "異常サンプル収集→特徴量抽出→モデル学習",
				"iterations": 100,
				"accuracy_improvement": "15%",
			}),
			Accuracy:      0.94,
			Coverage:      0.89,
			Consistency:   0.96,
			AbstractLevel: "L1",
			CreatedAt:     time.Now(),
			UpdatedAt:     time.Now(),
		},
	}

	for _, pattern := range patterns {
		var existing model.KnowledgePattern
		if err := db.Where("id = ?", pattern.ID).First(&existing).Error; err == gorm.ErrRecordNotFound {
			if err := db.Create(&pattern).Error; err != nil {
				return err
			}
		}
	}

	return nil
}

// seedOptimizationModels - 最適化モデルのシード
func seedOptimizationModels(db *gorm.DB) error {
	models := []model.OptimizationModel{
		{
			ID:            "energy_optimization",
			Name:          "エネルギー最適化",
			Type:          "ml_based",
			ObjectiveFunction: "minimize(energy_consumption) subject to performance_constraints",
			Constraints: "cycle_time_max: 3.0, accuracy_min: 0.02, payload: 5.0",
			Parameters: &model.NullString{
				String: "learning_rate: 0.001, batch_size: 32, epochs: 1000",
				Valid: true,
			},
			PerformanceMetric: &model.NullString{
				String: "energy_reduction: 32%, performance_maintained: true",
				Valid: true,
			},
			IterationCount:  &model.NullFloat64{Float64: 5000, Valid: true},
			ConvergenceRate: &model.NullFloat64{Float64: 0.98, Valid: true},
			Domain:          "robot_efficiency",
			CreatedAt:       time.Now(),
			UpdatedAt:       time.Now(),
		},
	}

	for _, optModel := range models {
		var existing model.OptimizationModel
		if err := db.Where("id = ?", optModel.ID).First(&existing).Error; err == gorm.ErrRecordNotFound {
			if err := db.Create(&optModel).Error; err != nil {
				return err
			}
		}
	}

	return nil
}

// seedRobotSpecifications - ロボット仕様のシード
func seedRobotSpecifications(db *gorm.DB) error {
	specs := []model.RobotArmSpecification{
		{
			ID:             "collaborative_robot_v2",
			ModelName:      "COBOT-2024",
			DOF:            7,
			Reach:          1200.0,
			Payload:        10.0,
			RepeatAccuracy: 0.01,
			MaxSpeed:       2000.0,
			WorkEnvelope: model.JSON(map[string]interface{}{
				"shape": "spherical",
				"radius": 1200,
				"dead_zones": []interface{}{},
			}),
			JointLimits: model.JSON(map[string]interface{}{
				"J1": []int{-180, 180},
				"J2": []int{-120, 120},
				"J3": []int{-180, 70},
				"J4": []int{-180, 180},
				"J5": []int{-120, 120},
				"J6": []int{-180, 180},
				"J7": []int{-360, 360},
			}),
			TeachingMethod: "ai",
			ControlSystem: model.JSON(map[string]interface{}{
				"type": "adaptive",
				"sensors": []string{"vision", "force", "proximity"},
				"ai_models": []string{"object_detection", "grasp_planning", "trajectory_optimization"},
			}),
			SafetyFeatures: model.JSON(map[string]interface{}{
				"collision_detection": true,
				"human_detection": true,
				"speed_scaling": true,
				"force_limiting": true,
				"emergency_stop": true,
			}),
			MaintenanceSchedule: model.JSON(map[string]interface{}{
				"predictive": true,
				"interval_hours": 2000,
				"key_components": []string{"joints", "motors", "sensors"},
			}),
			CreatedAt: time.Now(),
			UpdatedAt: time.Now(),
		},
	}

	for _, spec := range specs {
		var existing model.RobotArmSpecification
		if err := db.Where("id = ?", spec.ID).First(&existing).Error; err == gorm.ErrRecordNotFound {
			if err := db.Create(&spec).Error; err != nil {
				return err
			}
		}
	}

	return nil
}

// shouldUpdateExisting - 既存データを更新するかどうかの判定
func shouldUpdateExisting() bool {
	// 環境変数や設定ファイルから判定
	// デフォルトはfalse（既存データは更新しない）
	return false
}

// ExportSeedToJSON - 現在のデータをJSONファイルにエクスポート
func ExportSeedToJSON(db *gorm.DB) error {
	seedDir := "seed/data"
	
	// 現象学的フレームワークのエクスポート
	var frameworks []model.PhenomenologicalFramework
	if err := db.Find(&frameworks).Error; err != nil {
		return err
	}
	
	if data, err := json.MarshalIndent(frameworks, "", "  "); err == nil {
		filename := filepath.Join(seedDir, fmt.Sprintf("frameworks_%s.json", time.Now().Format("20060102_150405")))
		if err := ioutil.WriteFile(filename, data, 0644); err != nil {
			return err
		}
		log.Printf("Exported %d frameworks to %s", len(frameworks), filename)
	}
	
	// 知識パターンのエクスポート
	var patterns []model.KnowledgePattern
	if err := db.Find(&patterns).Error; err != nil {
		return err
	}
	
	if data, err := json.MarshalIndent(patterns, "", "  "); err == nil {
		filename := filepath.Join(seedDir, fmt.Sprintf("patterns_%s.json", time.Now().Format("20060102_150405")))
		if err := ioutil.WriteFile(filename, data, 0644); err != nil {
			return err
		}
		log.Printf("Exported %d patterns to %s", len(patterns), filename)
	}
	
	return nil
}

// IncrementalSeed - 増分シード（新規データのみ追加）
func IncrementalSeed(db *gorm.DB) error {
	log.Println("Running incremental seed...")
	
	// バージョン管理テーブルをチェック
	var seedVersion SeedVersion
	db.FirstOrCreate(&seedVersion, SeedVersion{Version: "1.0.0"})
	
	// バージョンに応じて追加データをシード
	switch seedVersion.Version {
	case "1.0.0":
		// v1.0.1の追加データ
		if err := seedV101Data(db); err != nil {
			return err
		}
		seedVersion.Version = "1.0.1"
	case "1.0.1":
		// v1.0.2の追加データ
		if err := seedV102Data(db); err != nil {
			return err
		}
		seedVersion.Version = "1.0.2"
	}
	
	// バージョン更新
	db.Save(&seedVersion)
	
	log.Printf("Seed updated to version %s", seedVersion.Version)
	return nil
}

// SeedVersion - シードバージョン管理
type SeedVersion struct {
	ID        uint      `gorm:"primaryKey"`
	Version   string    `gorm:"unique"`
	UpdatedAt time.Time
}

func seedV101Data(db *gorm.DB) error {
	// v1.0.1で追加するデータ
	return nil
}

func seedV102Data(db *gorm.DB) error {
	// v1.0.2で追加するデータ
	return nil
}